<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generate Rust bindings for GIR based libraries</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tutorial/introduction.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/preparation.html"><strong aria-hidden="true">2.1.</strong> Preparation</a></li><li class="chapter-item expanded "><a href="tutorial/finding_gir_files.html"><strong aria-hidden="true">2.2.</strong> Finding .gir files</a></li><li class="chapter-item expanded "><a href="tutorial/sys_library.html"><strong aria-hidden="true">2.3.</strong> Generating the FFI library</a></li><li class="chapter-item expanded "><a href="tutorial/high_level_rust_api.html"><strong aria-hidden="true">2.4.</strong> Generating the Rust API</a></li><li class="chapter-item expanded "><a href="tutorial/handling_errors.html"><strong aria-hidden="true">2.5.</strong> Handling generation errors</a></li><li class="chapter-item expanded "><a href="tutorial/generate_docs.html"><strong aria-hidden="true">2.6.</strong> Generating documentation</a></li></ol></li><li class="chapter-item expanded "><a href="config/introduction.html"><strong aria-hidden="true">3.</strong> Configuration files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/ffi.html"><strong aria-hidden="true">3.1.</strong> FFI Options</a></li><li class="chapter-item expanded "><a href="config/api.html"><strong aria-hidden="true">3.2.</strong> API Options</a></li><li class="chapter-item expanded "><a href="config/name_override.html"><strong aria-hidden="true">3.3.</strong> Crate name override</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Generate Rust bindings for GIR based libraries</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gtk-rs/gir/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/gtk-rs/gir">gir</a> is a tool to automatically generate safe wrappers for a C library with <a href="https://gi.readthedocs.io/en/latest/">GObject introspection</a> information.
In order to use it you need the <code>.gir</code> file containing the introspection data for the library you want to create the bindings for, as well as the <code>.gir</code> files for all its dependencies.
Have a look at the tutorial if you don't know how to <a href="tutorial/finding_gir_files.html">find the .gir files</a>.
If your library does not provide a <code>.gir</code> file, unfortunately you cannot use <a href="https://github.com/gtk-rs/gir">gir</a>, but maybe you can try <a href="https://github.com/rust-lang/rust-bindgen">rust-bindgen</a>.</p>
<p>This book contains a tutorial on how to use <a href="https://github.com/gtk-rs/gir">gir</a>.
As an example we will create the bindings for <a href="https://docs.gtk.org/Pango/">Pango</a>.
In many cases you will be able to follow the same steps with your library.
If you are already familiar with <a href="https://github.com/gtk-rs/gir">gir</a> and you just want to look up details about the configuration files, feel free to skip ahead to the documentation of the <a href="config/introduction.html">configuration files</a>.</p>
<h2 id="general-steps"><a class="header" href="#general-steps">General steps</a></h2>
<p><a href="https://github.com/gtk-rs/gir">gir</a> tries to make it as simple as possible to generate a safe wrapper for your C library.
The process can be divided into four steps that correspond to the four operating modes gir has.</p>
<ul>
<li>
<p>Generating unsafe bindings:
In this step, the low-level FFI bindings are created from the supplied <code>*.gir</code> files.
These are essentially direct calls into the related C library and are unsafe.
The resulting crate is typically appended with -sys.
The operating mode is <code>sys</code>.</p>
</li>
<li>
<p>Generating a safe wrapper:
Next, another crate for a layer on top of these unsafe (sys) bindings is created, which makes them safe for use in general Rust.
The operating mode is <code>normal</code>.</p>
</li>
<li>
<p>Checking for missing types/methods:
The operating mode <code>not_bound</code> allows you to see the detected types/methods that will not be generated for whatever reasons.</p>
</li>
<li>
<p>Adding documentation:
After the safe wrapper is created, gir can even generate the documentation for us.
Use the operating mode <code>doc</code> to do so.</p>
</li>
</ul>
<h2 id="regenerating-the-bindings-and-wrapper"><a class="header" href="#regenerating-the-bindings-and-wrapper">Regenerating the bindings and wrapper</a></h2>
<p>In order to generate the bindings and the wrapper for the first time, the above-mentioned steps should be followed.
When you want to regenerate the crates because e.g.
the library was updated, you can simplify the process by running the helper script <code>./generator.py</code>.
The script detects <code>Gir.toml</code> configurations in the current directory and subdirectories (or the paths passed on the command-line) and generates "normal" or "sys" crates for it.
Alternatively <code>--embed-docs</code> can be passed to prepare source-code for a documentation built by moving all documentation into it.
For a complete overview of available options, pass <code>--help</code>.</p>
<h2 id="gir-format-reference"><a class="header" href="#gir-format-reference">GIR format reference</a></h2>
<p>It can always be useful to look at the <a href="https://gi.readthedocs.io/en/latest/annotations/giannotations.html">reference</a> or <a href="https://gitlab.gnome.org/GNOME/gobject-introspection/blob/main/docs/gir-1.2.rnc">schema</a>.</p>
<h2 id="contact-us"><a class="header" href="#contact-us">Contact us</a></h2>
<p>If you use <a href="https://github.com/gtk-rs/gir">gir</a> on another library and it fails and you can't figure out why, don't hesitate to <a href="https://gtk-rs.org/contact">contact us</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>In this tutorial, we go through the basic steps needed to generate a safe wrapper for a simple C library.
We start with finding the .gir files needed and end with generating the documentation.
We also look at a few common errors and how to fix them.
Because this can be a bit abstract sometimes, we use the creation of the bindings for <a href="https://docs.gtk.org/Pango/">Pango</a> as an example.
The example continues through all of the chapters of the tutorial.
If you follow along until the end, you will have generated a safe wrapper including the documentation.
In case you are stuck at any point or there are other errors and you can't figure out what's going on, don't hesitate to reach us so we can give you a hand!</p>
<p>Let's dive right into it and let's set up our project folder!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preparation"><a class="header" href="#preparation">Preparation</a></h1>
<p>In order to install gir and nicely structure the project, there are a few things to set up.</p>
<h2 id="set-up-the-project-folder"><a class="header" href="#set-up-the-project-folder">Set up the project folder</a></h2>
<p>In order to keep the project folder nicely organized, let's create a folder where we will work in and initialize the repo.
We will create two library crates.
pango will contain the safe wrapper crate and because it is a wrapper for the unsafe bindings, we create the pango-sys crate within the pango crate.
If no Cargo.toml file is present in the sys create, a new one will be generated, so let's be safe and delete the automatically created file before we begin.
The following commands will set up the project folder as described.</p>
<pre><code class="language-sh">mkdir gir-tutorial
cd gir-tutorial/
git init
cargo new pango --lib
cd pango
cargo new pango-sys --lib
rm pango-sys/Cargo.toml
</code></pre>
<p>We will also create a file called "Gir.toml" in each of the crates.</p>
<pre><code class="language-sh">touch Gir.toml
touch pango-sys/Gir.toml
cd ..
</code></pre>
<h2 id="installing-gir"><a class="header" href="#installing-gir">Installing gir</a></h2>
<p>Of course we also need to download and install <a href="https://github.com/gtk-rs/gir">gir</a>.</p>
<pre><code class="language-sh">git submodule add https://github.com/gtk-rs/gir
git config -f .gitmodules submodule.gir.update none
git submodule set-branch --branch main -- ./gir
cd gir
cargo install --path .
cd ..
</code></pre>
<p>By adding it as a submodule, we are able to fetch future updates of the tool and we always exactly know which gir version we used to generate our bindings.
We also change the setting so that the submodule is not automatically checked out, otherwise anyone using your library from git will have the useless submodule checked out.
Run <code>git submodule update --checkout</code> if you want to update the submodule.
Then we set the branch of the submodule to main.</p>
<p>If there are any updates to gir in the future, we can install them by opening our project folder <code>gir-tutorial</code> and running</p>
<pre><code class="language-sh">git submodule update --remote
cd gir
cargo install --path .
cd ..
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>You should now have a folder looking like this:</p>
<pre><code class="language-text">gir
  |
  |---- ...
pango/
  |
  |---- Cargo.toml
  |---- Gir.toml
  |---- pango-sys/
  |       |
  |       |---- Gir.toml
  |       |---- src/
  |              |
  |              |---- lib.rs
  |---- src/
          |
          |---- lib.rs
.git
  |
  |---- ...
.gitmodules
</code></pre>
<p>Now that we installed gir and prepared our project folder, let's get the .gir files.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="where-can-i-find-those-gir-files"><a class="header" href="#where-can-i-find-those-gir-files">Where can I find those .gir files?</a></h1>
<p>There are multiple ways you can get the needed <code>.gir</code> files.
The <code>*.gir</code> you need corresponds to the library you want to generate bindings for.
If you have the library installed, you can search for the <code>.gir</code> file under <code>/usr/share/gir-1.0/</code>.
Having the library installed is a good idea so that you can test the generated code.
Otherwise you should be able to get it from the package that installs the library.
Ubuntu for example allows you to <a href="https://packages.ubuntu.com/">search</a> for packages and download them via their website.
You can copy the <code>.gir</code> file of your library to the root of your project folder.
You don't have to store all <code>.gir</code> files in the same folder.
You can add multiple paths by changing the <code>girs_directories</code> field in the Gir.toml files.
More on this in the next chapters.</p>
<p>Have a look at the .gir file of your library.
At the beginning of the file, you probably see something similar to <code>&lt;include name="GObject" version="2.0"/&gt;</code>.
"GObject" in this case would be a dependency and you will have to find the .gir file for your dependencies as well.
In most cases it will be enough to follow the next two steps of the tutorial to get all needed files.</p>
<h2 id="gtk-dependencies"><a class="header" href="#gtk-dependencies">GTK dependencies</a></h2>
<p>If your library depends on GTK libraries, the recommended way to get the <code>.gir</code> files for them is to add the <a href="https://github.com/gtk-rs/gir-files">gir-files repo</a> as a submodule as well.
It's the recommended way, because some of the <code>.gir</code> files included in the libraries are invalid (missing or invalid annotations for example).
These errors are already fixed in the gir files from the repo.
Otherwise you could use the above-mentioned methods to find the files and run the <a href="https://github.com/gtk-rs/gir-files/blob/main/fix.sh">script</a> to fix the <code>.gir</code> files available in the gir-files repository (and only them!).
You can run it like this (at the same level of the <code>.gir</code> files you want to patch):</p>
<pre><code class="language-sh">sh fix.sh
</code></pre>
<h2 id="gstreamer-dependencies"><a class="header" href="#gstreamer-dependencies">GStreamer dependencies</a></h2>
<p>For GStreamer related dependencies, follow the above-mentioned steps but add this <a href="https://gitlab.freedesktop.org/gstreamer/gir-files-rs">repo</a> instead.</p>
<h2 id="other-dependencies"><a class="header" href="#other-dependencies">Other dependencies</a></h2>
<p>If you have other dependencies, you have to find the files yourself.
They can often be found in the repo containing the source of your dependencies or if you have them installed, you might find them under <code>/usr/share/gir-1.0/</code> again.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>We want to generate the wrapper for pango.
It is related to GTK, so in order to get its .gir files, we use the recommended way.
While being in the project folder <code>git-tutorial</code>, we add the <a href="https://github.com/gtk-rs/gir-files">gir-files repo</a> as a submodule and set the branch of the submodule to main.</p>
<pre><code class="language-sh">git submodule add https://github.com/gtk-rs/gir-files
git config -f .gitmodules submodule.gir-files.update none
git submodule set-branch --branch main -- ./gir-files
</code></pre>
<p>We also change the setting so that the submodule is not automatically checked out, otherwise anyone using your library from git will have the useless submodule checked out.
Run <code>git submodule update --checkout</code> if you want to update the submodule.
If you look into <code>gir-files</code>, you'll see a file named <code>Pango-1.0.gir</code>.
That's the one for pango.
Because we already added the gir-files repo, we also have all the other .gir files of the dependencies that we need.
Now we can create the unsafe bindings.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-the-ffi-library"><a class="header" href="#generating-the-ffi-library">Generating the FFI library</a></h1>
<p>We have installed <a href="https://github.com/gtk-rs/gir">gir</a>, set up our repo and have all the <code>.gir</code> files we need.
Now let's work on the unsafe bindings of the -sys crate.
Let's change into the directory of the sys crate.</p>
<pre><code class="language-sh">cd pango/pango-sys
</code></pre>
<h2 id="the-girtoml-file"><a class="header" href="#the-girtoml-file">The Gir.toml file</a></h2>
<p>The first step is to let <a href="https://github.com/gtk-rs/gir">gir</a> know what to generate.
This is what the <code>Gir.toml</code> file that we created inside the <code>pango-sys</code> folder is for.
This file will not be replaced when we run gir again.
The file is currently empty so let's add the following to it:</p>
<pre><code class="language-toml">[options]
library = "Pango"
version = "1.0"
min_cfg_version = "1.0"
target_path = "."
girs_directories = ["../../gir-files/"]
work_mode = "sys"
single_version_file = true
</code></pre>
<ul>
<li><code>library</code> stands for the name of the library we want to generate.</li>
<li><code>version</code> stands for the version of the library to be used.</li>
<li><code>min_cfg_version</code> will be the minimum version supported by the generated bindings.</li>
<li><code>target_path</code> stands for the location where the files will be generated.</li>
<li><code>girs_directories</code> stands for the location of the <code>.gir</code> files.</li>
<li><code>work_mode</code> stands for the mode gir is using.
The options here are <code>sys</code> and <code>normal</code>.</li>
<li><code>single_version_file</code> is a very useful option when you have a lot of generated files (like we'll have).
Instead of generating the gir hash commit used for the generation in the header of all generated files, it'll just write it inside one file, removing <code>git diff</code> noise <strong>a lot</strong>.</li>
</ul>
<p>You can find out the values for <code>library</code> and <code>version</code> by looking at the name of the .gir file of your library.
In our case it is called Pango-1.0.gir.
This tells us that the <code>library</code> is Pango and the <code>version</code> is 1.0.
If you don't know what value to use for <code>min_cfg_version</code>, use the same as you use for <code>version</code>.
If not all needed <code>.gir</code> files reside in <code>../../gir-files/</code>, you can add the path to the other files by changing <code>girs_directories</code>.
If for example you also have <code>.gir</code> files in the root of your project folder, change it to <code>girs_directories = ["../../gir-files/", "../.."]</code>.
Because we are generating the unsafe bindings, we use the <code>sys</code> work mode.</p>
<p>Let's generate the <code>sys</code> crate now:</p>
<pre><code class="language-sh">gir -o .
</code></pre>
<p>You should now see new files and a new folder.</p>
<ul>
<li><code>build.rs</code></li>
<li><code>Cargo.toml</code></li>
<li><code>Gir.toml</code></li>
<li><code>src/lib.rs</code></li>
<li><code>tests/</code></li>
</ul>
<p>Now let's try to build it:</p>
<pre><code class="language-sh">cargo build
</code></pre>
<p>Surprise.
It doesn't build at all and you should see a lot of errors.
Well, that was expected.
We need to add some dependencies in order to make it work.
Have a look at the errors of the compiler to find out which are missing.
In our example, the compiler throws the following errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use of undeclared crate or module `glib`
use of undeclared crate or module `gobject`
<span class="boring">}</span></code></pre></pre>
<p>The dependencies need to be added to the <code>external_libraries</code> part.
The names of the dependencies are the same as in the .gir files and not what the packages to install the libraries might be called.
The compiler told us that the <code>GLib</code> and the <code>GObject</code> dependencies are missing.
Let's update our <code>Gir.toml</code> file to fix it:</p>
<pre><code class="language-toml">[options]
library = "Pango"
version = "1.0"
min_cfg_version = "1.0"
target_path = "."
girs_directories = ["../../gir-files/"]
work_mode = "sys"

external_libraries = [
    "GLib",
    "GObject",
]
</code></pre>
<p>If one of your .gir files changed or you want to use an updated version of gir to generate the code, there is no need to delete the Cargo.toml or the Cargo.lock files before you regenerate the code.
Because we made some changes to the Gir.toml file, we have to run gir again.
Changing the content of the external_libraries array means that additional dependencies have to be added.
gir does this automatically for you, but only if there is no Cargo.toml and no Cargo.lock file present.
Just remove the <code>Cargo.*</code> files and run gir again and the additional dependencies will be added.
If you made any manual changes to the file, you would have to do these changes again.
After regenerating the code, we build the crate to see if the errors are gone.</p>
<pre><code class="language-sh">rm Cargo.*
gir -o .
cargo build
</code></pre>
<p>When executing the above commands, there should not be any errors and everything should work fine.
Just to be sure everything was correctly generated, we can run some tests (graciously generated by <a href="https://github.com/gtk-rs/gir">gir</a> as well):</p>
<pre><code class="language-sh">cargo test
</code></pre>
<p>Normally, all tests passed.
If you get an error when running those tests, it's very likely that the <code>sys</code> generation is invalid and/or incomplete.</p>
<h2 id="the-girtoml-file-1"><a class="header" href="#the-girtoml-file-1">The Gir.toml file</a></h2>
<p>This file was automatically generated but it will not be replaced when we run gir again.
Make sure to look at your Cargo.toml to optionally add more information to it.
If there are any <code>[features]</code>, you should try building and testing with these features activated as well.
If you'd like, you can also set the default features.
This can be useful for example if you want to always activate the newest version unless the user of the crate specifies an older version.</p>
<p>For our example, we now have a working <code>sys</code> crate containing all functions and objects definition.
We are done here and can go back to the folder of the wrapper crate:</p>
<pre><code class="language-sh">cd ..
</code></pre>
<p>Time to generate the high-level Rust API!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-the-rust-api"><a class="header" href="#generating-the-rust-api">Generating the Rust API</a></h1>
<p>In the previous step we successfully created the unsafe bindings of the -sys crate.
We are now in the directory of the safe wrapper crate (<code>gir-tutorial/pango</code>).</p>
<h2 id="the-cargotoml-file"><a class="header" href="#the-cargotoml-file">The Cargo.toml file</a></h2>
<p>The Cargo.toml file will not be replaced when you run gir.
So it is our responsibility to make sure the information in it is correct.
Open the Cargo.toml file and have a look at it.
Make sure everything under <code>[package]</code> is to your liking.</p>
<p>Add the following lines to the file:</p>
<pre><code class="language-toml">[package.metadata.docs.rs]
all-features = true
# For build.rs scripts
rustc-args = ["--cfg", "docsrs"]
# For rustdoc
rustdoc-args = ["--cfg", "docsrs"]
</code></pre>
<p>This automatically activates the <code>docsrs</code> attribute if you chose to publish the bindings and docs.rs tries to build the documentation.
With the <code>docsrs</code> attribute, the crate skips linking the C libraries and allows docs.rs to build the documentation without having the underlying libraries installed.
Even if you don't plan to publish it, this line is not going to hurt.</p>
<p>We also need to add <code>libc</code>, <code>bitflags</code>, <code>glib</code> and <code>glib-sys</code> and all other dependencies we used in the sys crate as dependencies.
Because we are creating a wrapper for the sys crate, which we generated in the previous chapter, we also need to add the sys crate to the list of dependencies.
In the automatically generated code, the sys crate is always called <code>ffi</code>, so we need to rename the sys crate in our <code>Cargo.toml</code>.
For our example, this results in the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
libc = "0.2"
bitflags = "2.2"

[dependencies.ffi]
package = "pango-sys"
path = "./pango-sys"

[dependencies.glib]
package = "glib-sys"
git = "https://github.com/gtk-rs/gtk-rs-core"

[dependencies.gobject]
package = "gobject-sys"
git = "https://github.com/gtk-rs/gtk-rs-core"
</code></pre>
<p>In order to make the features of the sys crate available for users of your safe wrapper, you need to add features.
Copy the <code>[features]</code> part of the Cargo.toml of your sys crate and paste it into the Cargo.toml of the normal crate.
The features are supposed to activate the corresponding features of the sys crate, so you need to make some changes.
If for example you have the following sys features:</p>
<pre><code class="language-toml">[features]
v1_2 = []
v1_4 = ["v1_2"]
v1_6 = ["v1_4"]
v1_8 = ["v1_6"]
v1_10 = ["v1_8"]
v1_12 = ["v1_10"]
v1_14 = ["v1_12"]
v1_16 = ["v1_14"]
v1_18 = ["v1_16"]
v1_20 = ["v1_18"]
v1_22 = ["v1_20"]
v1_24 = ["v1_22"]
v1_26 = ["v1_24"]
v1_30 = ["v1_26"]
v1_31 = ["v1_30"]
v1_32 = ["v1_31"]
v1_32_4 = ["v1_32"]
v1_34 = ["v1_32_4"]
v1_36_7 = ["v1_34"]
v1_38 = ["v1_36_7"]
v1_42 = ["v1_38"]
v1_44 = ["v1_42"]
v1_46 = ["v1_44"]
v1_48 = ["v1_46"]
v1_50 = ["v1_48"]
v1_52 = ["v1_50"]
</code></pre>
<p>You need to change the features in the Cargo.toml of your normal crate to</p>
<pre><code class="language-toml">[features]
v1_2 = ["ffi/v1_2"]
v1_4 = ["ffi/v1_4", "v1_2"]
v1_6 = ["ffi/v1_6", "v1_4"]
v1_8 = ["ffi/v1_8", "v1_6"]
v1_10 = ["ffi/v1_10", "v1_8"]
v1_12 = ["ffi/v1_12", "v1_10"]
v1_14 = ["ffi/v1_14", "v1_12"]
v1_16 = ["ffi/v1_16", "v1_14"]
v1_18 = ["ffi/v1_18", "v1_16"]
v1_20 = ["ffi/v1_20", "v1_18"]
v1_22 = ["ffi/v1_22", "v1_20"]
v1_24 = ["ffi/v1_24", "v1_22"]
v1_26 = ["ffi/v1_26", "v1_24"]
v1_30 = ["ffi/v1_30", "v1_26"]
v1_31 = ["ffi/v1_31", "v1_30"]
v1_32 = ["ffi/v1_32", "v1_31"]
v1_32_4 = ["ffi/v1_32_4", "v1_32"]
v1_34 = ["ffi/v1_34", "v1_32_4"]
v1_36_7 = ["ffi/v1_36_7", "v1_34"]
v1_38 = ["ffi/v1_38", "v1_36_7"]
v1_42 = ["ffi/v1_42", "v1_38"]
v1_44 = ["ffi/v1_44", "v1_42"]
v1_46 = ["ffi/v1_46", "v1_44"]
v1_48 = ["ffi/v1_48", "v1_46"]
v1_50 = ["ffi/v1_50", "v1_48"]
v1_52 = ["ffi/v1_52", "v1_50"]
</code></pre>
<h2 id="the-librs-file"><a class="header" href="#the-librs-file">The lib.rs file</a></h2>
<p>The lib.rs file will not be replaced when you run gir.
All the code that gir will generate for us is going to be in src/auto.
We need to include all <code>auto</code> files in our library.
Also it needs to include sys create so auto files can use it.
To do so, let's update the <code>src/lib.rs</code> file as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![cfg_attr(docsrs, feature(doc_cfg))]

<span class="boring">fn main() {
</span>use ffi;
pub use auto::*;
mod auto;
<span class="boring">}</span></code></pre></pre>
<h2 id="the-girtoml-file-2"><a class="header" href="#the-girtoml-file-2">The Gir.toml file</a></h2>
<p>As you certainly guessed, we have to fill our <code>Gir.toml</code> file for the normal crate as well.
Let's write it:</p>
<pre><code class="language-toml">[options]
library = "Pango"
version = "1.0"
min_cfg_version = "1.0"
target_path = "."
girs_directories = ["../gir-files"]
work_mode = "normal"
single_version_file = true
generate_safety_asserts = true
deprecate_by_min_version = true

generate = []

manual = []
</code></pre>
<p>Many of these options look familiar from the last chapter but there are also a few new things in here.
Let's take a look at them:</p>
<ul>
<li><code>work_mode</code> value is now set to <code>normal</code>, it means it'll generate the high-level Rust api instead of the sys-level.</li>
<li><code>generate_safety_asserts</code> is used to generates checks to ensure that, or any other kind of initialization needed before being able to use the library.</li>
<li><code>deprecate_by_min_version</code> is used to generate a <a href="https://doc.rust-lang.org/edition-guide/rust-2018/the-compiler/an-attribute-for-deprecation.html">Rust "#[deprecated]"</a> attribute based on the deprecation information provided by the <code>.gir</code> file.</li>
<li><code>generate = []</code>: this line currently does nothing.
We say to <a href="https://github.com/gtk-rs/gir">gir</a> to generate nothing.
We'll fill it later on.</li>
<li><code>manual = []</code>: this line currently does nothing.
We can let <a href="https://github.com/gtk-rs/gir">gir</a> know about objects which it does not have to generate code for.</li>
</ul>
<p>Let's make a first generation of our high-level Rust API!</p>
<pre><code class="language-sh">gir -o .
</code></pre>
<p>If you take a look at which files and folders were created, you'll see a new "auto" folder inside "src".
This folder contains all the generated code.
It doesn't contain anything though.
Which makes sense since we're generating nothing.</p>
<p>Now it's time to introduce you to a whole new <a href="https://github.com/gtk-rs/gir">gir</a> mode: <code>not_bound</code>.
Let's give it a try:</p>
<pre><code class="language-console">&gt; gir -o . -m not_bound
[NOT GENERATED] Pango.Glyph
[NOT GENERATED] Pango.GlyphUnit
[NOT GENERATED] Pango.GlyphItem
[NOT GENERATED] Pango.LayoutRun
[NOT GENERATED] Pango.Alignment
[NOT GENERATED] Pango.Font
[NOT GENERATED] Pango.Language
[NOT GENERATED] Pango.Analysis
[NOT GENERATED] Pango.AttrType
[NOT GENERATED] Pango.Attribute
[NOT GENERATED] Pango.Color
[NOT GENERATED] Pango.AttrColor
[NOT GENERATED] Pango.AttrFloat
[NOT GENERATED] Pango.FontDescription
[NOT GENERATED] Pango.AttrFontDesc
[NOT GENERATED] Pango.AttrFontFeatures
[NOT GENERATED] Pango.AttrInt
[NOT GENERATED] Pango.AttrIterator
[NOT GENERATED] Pango.AttrLanguage
[NOT GENERATED] Pango.AttrList
[NOT GENERATED] Pango.Rectangle
[NOT GENERATED] Pango.AttrShape
[NOT GENERATED] Pango.AttrSize
[NOT GENERATED] Pango.AttrString
[NOT GENERATED] Pango.BaselineShift
[NOT GENERATED] Pango.BidiType (deprecated in 1.44)
[NOT GENERATED] Pango.Context
[NOT GENERATED] Pango.Direction
[NOT GENERATED] Pango.Gravity
[NOT GENERATED] Pango.FontMap
[NOT GENERATED] Pango.GravityHint
[NOT GENERATED] Pango.Matrix
[NOT GENERATED] Pango.FontMetrics
[NOT GENERATED] Pango.FontFamily
[NOT GENERATED] Pango.Fontset
[NOT GENERATED] Pango.Coverage
[NOT GENERATED] Pango.CoverageLevel
[NOT GENERATED] Pango.EllipsizeMode
[NOT GENERATED] Pango.FontFace
[NOT GENERATED] Pango.FontMask
[NOT GENERATED] Pango.Stretch
[NOT GENERATED] Pango.Style
[NOT GENERATED] Pango.Variant
[NOT GENERATED] Pango.Weight
[NOT GENERATED] Pango.FontScale
[NOT GENERATED] Pango.FontsetSimple
[NOT GENERATED PARENT] Pango.Fontset
[NOT GENERATED] Pango.GlyphGeometry
[NOT GENERATED] Pango.GlyphVisAttr
[NOT GENERATED] Pango.GlyphInfo
[NOT GENERATED] Pango.Item
[NOT GENERATED] Pango.GlyphString
[NOT GENERATED] Pango.LogAttr
[NOT GENERATED] Pango.GlyphItemIter
[NOT GENERATED] Pango.Script
[NOT GENERATED] Pango.Layout
[NOT GENERATED] Pango.LayoutDeserializeFlags
[NOT GENERATED] Pango.LayoutIter
[NOT GENERATED] Pango.LayoutLine
[NOT GENERATED] Pango.TabArray
[NOT GENERATED] Pango.WrapMode
[NOT GENERATED] Pango.LayoutSerializeFlags
[NOT GENERATED] Pango.LayoutDeserializeError
[NOT GENERATED] Pango.Overline
[NOT GENERATED] Pango.RenderPart
[NOT GENERATED] Pango.Renderer
[NOT GENERATED] Pango.Underline
[NOT GENERATED] Pango.ScriptIter
[NOT GENERATED] Pango.ShapeFlags
[NOT GENERATED] Pango.ShowFlags
[NOT GENERATED] Pango.TabAlign
[NOT GENERATED] Pango.TextTransform
[NOT GENERATED FUNCTION] Pango.attr_allow_breaks_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_background_alpha_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_background_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_baseline_shift_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_break because of Pango.AttrList and Pango.LogAttr
[NOT GENERATED FUNCTION] Pango.attr_fallback_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_family_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_font_scale_new because of Pango.FontScale and Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_foreground_alpha_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_foreground_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_gravity_hint_new because of Pango.GravityHint and Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_gravity_new because of Pango.Gravity and Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_insert_hyphens_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_letter_spacing_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_line_height_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_line_height_new_absolute because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_overline_color_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_overline_new because of Pango.Overline and Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_rise_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_scale_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_sentence_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_show_new because of Pango.ShowFlags and Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_stretch_new because of Pango.Stretch and Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_strikethrough_color_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_strikethrough_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_style_new because of Pango.Style and Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_text_transform_new because of Pango.TextTransform and Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_underline_color_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_underline_new because of Pango.Underline and Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_variant_new because of Pango.Variant and Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_weight_new because of Pango.Weight and Pango.Attribute
[NOT GENERATED FUNCTION] Pango.attr_word_new because of Pango.Attribute
[NOT GENERATED FUNCTION] Pango.break (deprecated in 1.44) because of Pango.Analysis and Pango.LogAttr
[NOT GENERATED FUNCTION] Pango.default_break because of Pango.Analysis and Pango.LogAttr
[NOT GENERATED FUNCTION] Pango.extents_to_pixels because of Pango.Rectangle and Pango.Rectangle
[NOT GENERATED FUNCTION] Pango.find_base_dir because of Pango.Direction
[NOT GENERATED FUNCTION] Pango.get_log_attrs because of Pango.Language and Pango.LogAttr
[NOT GENERATED FUNCTION] Pango.itemize because of Pango.Context, Pango.AttrList, Pango.AttrIterator and Pango.Item
[NOT GENERATED FUNCTION] Pango.itemize_with_base_dir because of Pango.Context, Pango.Direction, Pango.AttrList, Pango.AttrIterator and Pango.Item
[NOT GENERATED FUNCTION] Pango.log2vis_get_embedding_levels because of Pango.Direction
[NOT GENERATED FUNCTION] Pango.markup_parser_finish because of GLib.MarkupParseContext, Pango.AttrList and GLib.Error
[NOT GENERATED FUNCTION] Pango.markup_parser_new because of GLib.MarkupParseContext
[NOT GENERATED FUNCTION] Pango.parse_markup because of Pango.AttrList and GLib.Error
[NOT GENERATED FUNCTION] Pango.parse_stretch because of Pango.Stretch
[NOT GENERATED FUNCTION] Pango.parse_style because of Pango.Style
[NOT GENERATED FUNCTION] Pango.parse_variant because of Pango.Variant
[NOT GENERATED FUNCTION] Pango.parse_weight because of Pango.Weight
[NOT GENERATED FUNCTION] Pango.read_line (deprecated in 1.38) because of GLib.String
[NOT GENERATED FUNCTION] Pango.reorder_items because of Pango.Item and Pango.Item
[NOT GENERATED FUNCTION] Pango.scan_string (deprecated in 1.38) because of GLib.String
[NOT GENERATED FUNCTION] Pango.scan_word (deprecated in 1.38) because of GLib.String
[NOT GENERATED FUNCTION] Pango.shape because of Pango.Analysis and Pango.GlyphString
[NOT GENERATED FUNCTION] Pango.shape_full because of Pango.Analysis and Pango.GlyphString
[NOT GENERATED FUNCTION] Pango.shape_item because of Pango.Item, Pango.LogAttr, Pango.GlyphString and Pango.ShapeFlags
[NOT GENERATED FUNCTION] Pango.shape_with_flags because of Pango.Analysis, Pango.GlyphString and Pango.ShapeFlags
[NOT GENERATED FUNCTION] Pango.tailor_break because of Pango.Analysis and Pango.LogAttr
[NOT GENERATED FUNCTION] Pango.unichar_direction because of Pango.Direction
</code></pre>
<p>We now have the list of all the not-yet generated items.
Quite convenient.
There can be different kinds of not generated items:</p>
<ul>
<li><code>[NOT GENERATED]</code>:
Objects marked with <code>[NOT GENERATED]</code> are objects that we can generate, but we did not (yet) add to the <code>generate</code> array.</li>
<li><code>[NOT GENERATED PARENT]</code>:
These objects live in a dependency of the current library.
These are the objects we will add to the <code>manual</code> array in the following steps.</li>
<li><code>[NOT GENERATED FUNCTION]</code>:
These are global functions that were not generated.
To fix it, we just add <code>"NameOfYourLibrary.*"</code> to the <code>generate</code> array in the Git.toml and add the following line to your src/lib.rs file:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod functions {
  pub use super::auto::functions::*;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="generating-the-code"><a class="header" href="#generating-the-code">Generating the code</a></h2>
<p>In order to generate the code for the safe wrapper, we follow these steps until all objects have been generated:</p>
<ul>
<li>Run <code>gir -o . -m not_bound</code> to see which objects have not been generated yet</li>
<li>Pick one of the types marked with <code>[NOT GENERATED]</code></li>
<li>Add it to the <code>generate</code> array in the Gir.toml file</li>
<li>Run <code>gir -o .</code> to generate the code</li>
<li>Open the generated files under src/auto and have a look at them</li>
<li>Search for <code>/*Ignored*/</code>.
If the type name following <code>/*Ignored*/</code> is prepended by <code>[crate_name]::</code> (e.g <code>Ignored*/&amp;glib::MarkupParseContext</code>),
<ul>
<li>then we add it to the <code>manual</code> array.
By doing so we tell <a href="https://github.com/gtk-rs/gir">gir</a> that those types have been generated somewhere else and that they can be used just like the other types.</li>
<li>Otherwise, the type comes from the current crate and we just put it into the <code>generate</code> list of the <code>Gir.toml</code> file.</li>
</ul>
</li>
<li>Start with the first step again</li>
</ul>
<p>The names of the objects are not the same as the crates names.
You have to use the names of the corresponding gir files.</p>
<p>Okay, let's go through that process for a few objects of our example.</p>
<p>🚧 TODO: Add remaining steps of the pango example 🚧</p>
<p>Again, if you do it on another library and it fails and you can't figure out why, don't hesitate to <a href="https://gtk-rs.org/contact">contact us</a>!</p>
<p>At this point, you should have almost everything you need.
Let's have a look at errors that can happen in this process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-generation-errors"><a class="header" href="#handling-generation-errors">Handling generation errors</a></h1>
<p>Luckily there are only a few errors which can happen with <a href="https://github.com/gtk-rs/gir">gir</a> generation.
Let's take a look at them.</p>
<h3 id="cannot-find-macros"><a class="header" href="#cannot-find-macros">Cannot find macros</a></h3>
<p>Compilation of the generated bindings may fail with errors like the following:</p>
<pre><code class="language-console">error: cannot find macro `skip_assert_initialized` in this scope
  --&gt; src/auto/enums.rs:83:9
   |
83 |         skip_assert_initialized!();
   |         ^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: have you added the `#[macro_use]` on the module/import?

error: cannot find macro `assert_initialized_main_thread` in this scope
  --&gt; src/auto/example.rs:33:9
   |
33 |         assert_initialized_main_thread!();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: have you added the `#[macro_use]` on the module/import?
</code></pre>
<p>In this case you’ll have to implement them yourself.
Macros are order-dependent and you <em>must</em> insert this code before declaring modules that use it (e.g. <code>mod auto</code>).
For example, you can add the following to your <code>lib.rs</code> file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// No-op.
macro_rules! skip_assert_initialized {
    () =&gt; {};
}

/// Asserts that this is the main thread and either `gdk::init` or `gtk::init` has been called.
macro_rules! assert_initialized_main_thread {
    () =&gt; {
        if !::gtk::is_initialized_main_thread() {
            if ::gtk::is_initialized() {
                panic!("GTK may only be used from the main thread.");
            } else {
                panic!("GTK has not been initialized. Call `gtk::init` first.");
            }
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<p>One complication here is that the <code>assert_initialized_main_thread!</code> macro depends on the exact library.
If it's GTK-based then the above macro is likely correct, unless the library has its own initialization function.
If it has its own initialization function it would need to be handled in addition to GTK's here in the same way.</p>
<p>For non-GTK-based libraries the following macro would handle the initialization function of that library in the same way, or if there is none it would simply do nothing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// No-op.
macro_rules! assert_initialized_main_thread {
    () =&gt; {};
}
<span class="boring">}</span></code></pre></pre>
<h2 id="missing-memory-management-functions"><a class="header" href="#missing-memory-management-functions">Missing memory management functions</a></h2>
<p>If <a href="https://github.com/gtk-rs/gir">gir</a> generation fails (for whatever reason), it means you'll have to implement the type yourself.
Just like types from other <code>gtk-rs</code> crates, you'll need to put it into the "manual" list.
Then you need to put the type into the <code>src</code> folder (or inside a subfolder, you know how Rust works).</p>
<p>/!\ Don't forget to reexport the type inside your <code>src/lib.rs</code> file.
For example, let's take a look at the <a href="https://github.com/gtk-rs/gtk3-rs/blob/master/gtk/src/requisition.rs">requisition.rs</a> file from the <code>gtk3</code> crate.</p>
<p>Since it's a "simple" type (no pointer, therefore no memory management to do), <a href="https://github.com/gtk-rs/gir">gir</a> doesn't know how to generate it.
You'll need to implement some traits by hand like <code>ToGlibPtr</code> or <code>ToGlibPtrMut</code> (depending on your needs).</p>
<h2 id="bad-function-generation"><a class="header" href="#bad-function-generation">Bad function generation</a></h2>
<p>In some cases, the generated code isn't correct (array parameters are often an issue).
In such cases, it's better to just make the implementation yourself.
As an example, let's say you want to implement <code>Region::is_empty</code> yourself.
A few changes have to be made.
Let's start with <code>Gir.toml</code>:</p>
<pre><code class="language-toml">generate = [
    "GtkSource.Language",
]

[[object]]
name = "GtkSource.Region"
status = "generate"
    [[object.function]]
    name = "is_empty"
    ignore = true
</code></pre>
<p>So to sum up what was written above: we removed "GtkSource.Region" from the "generate" list and we created a new entry for it.
Then we say to <a href="https://github.com/gtk-rs/gir">gir</a> that it should generate (through <code>status = "generate"</code>).
However, we also tell it that we don't want the "is_empty" function to be generated.</p>
<p>Now that we've done that, we need to implement it.
Let's create a <code>src/region.rs</code> file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use glib::object::IsA;
use glib::translate::*;
use Region;

pub trait RegionExtManual: 'static {
    pub fn is_empty(&amp;self) -&gt; bool;
}

impl&lt;O: IsA&lt;Region&gt;&gt; RegionExtManual for O {
    pub fn is_empty(&amp;self) -&gt; bool {
        // blablabla
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You might wonder: "why not just implementing it on the <code>Region</code> type directly?".
Because like this, a subclass will also be able to use this trait easily as long as it implements <code>IsA&lt;Region&gt;</code>.
For instance, in gtk, everything that implements <code>IsA&lt;Widget&gt;</code> (so almost every GTK types) can use those methods.</p>
<p>As usual, don't forget to reexport the trait.
A little tip about reexporting manual traits: in <code>gtk3-rs</code>, we create a <code>src/prelude.rs</code> file which reexports all traits (both manual and generated ones), making it simpler for users to use them through <code>use [DEPENDENCY]::prelude::*</code>.
The <code>src/prelude.rs</code> file looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use crate::auto::traits::*;
pub use region::RegionExtManual;
<span class="boring">}</span></code></pre></pre>
<p>Then it's reexported as follows from the <code>src/lib.rs</code> file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod prelude;
pub use prelude::*;
<span class="boring">}</span></code></pre></pre>
<h2 id="manually-defined-traits-missing-from-the-documentation"><a class="header" href="#manually-defined-traits-missing-from-the-documentation">Manually defined traits missing from the documentation</a></h2>
<p>If you defined traits manually, you can add them to the "Implements" section in the documentation for classes and interfaces by using the <code>manual_traits = []</code> option in the <code>Gir.toml</code> file.
Here is an example:</p>
<pre><code class="language-toml">[[object]]
name = "Gtk.Assistant"
status = "generate"
#add link to trait from current crate
manual_traits = ["AssistantExtManual"]

[[object]]
name = "Gtk.Application"
status = "generate"
#add link to trait from other crate
manual_traits = ["gio::ApplicationExtManual"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-documentation"><a class="header" href="#generating-documentation">Generating documentation</a></h1>
<p>And finally the last feature.
Just run the following command in the folder of the safe wrapper crate:</p>
<pre><code class="language-sh">gir -c Gir.toml -d ../gir-files --doc-target-path docs.md -m doc
</code></pre>
<ul>
<li><code>-d ../gir-files</code>: flag to select the folder containing the .gir files.</li>
<li><code>--doc-target-path docs.md</code>: flag to select the name of the markdown file containing the documentation.</li>
<li><code>-m doc</code>: flag to select the work mode for generating the documentation.</li>
</ul>
<p>It'll generate a markdown file if everything went fine.
It contains all of the crate's documentation.
If you want to put it into your crate's source code like "normal" doc comments, run:</p>
<pre><code class="language-sh">cargo install rustdoc-stripper
rustdoc-stripper -g -o docs.md
</code></pre>
<p>And now your crate should be completely documented as expected!</p>
<p>Running the above commands again would duplicate the doc comments.
Make sure to first remove the old ones before running the command again.
You can do this by running the following commands:</p>
<pre><code class="language-sh">rustdoc-stripper -s -n
rustdoc-stripper -g -o docs.md
</code></pre>
<p>Try building the documentation and also try it with the various features you might have:</p>
<pre><code class="language-sh">cargo doc
</code></pre>
<p>For building the docs on systems without the required dependencies installed (for example docs.rs or CI jobs), you can use the <code>docsrs</code> attribute.
This will disable the linking of the underlying C libraries and won't throw an error if those libraries are not available.</p>
<p>On top of that, the <code>docsrs</code> attribute will enable the <a href="https://doc.rust-lang.org/beta/unstable-book/language-features/doc-cfg.html">doc_cfg feature</a> which is only available in the nightly compiler toolchain at the time of writing.
This is mostly useful for clarifying feature requirements through the docs.</p>
<p>To build the docs with the <code>docsrs</code> attribute, you can use the following command:</p>
<pre><code class="language-sh">RUSTFLAGS='--cfg docsrs' RUSTDOCFLAGS='--cfg docsrs' cargo +nightly doc --all-features
</code></pre>
<p>Congratulations, we are done.
You have successfully created the safe wrapper for a C library!</p>
<p>You can easily publish your generated bindings and the wrapper to crates.io to allow others to use it.
Publishing crates is easy but keep in mind that they need to be maintained as well.
We set up the project folder in a way that easily allows sharing the code.
All that is needed is to add some information to your Cargo.toml.
Gir will not override them when you re-generate bindings.
Easy, right.
If this is your first time publishing a crate, you can find a detailed guide <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">here</a>.</p>
<p>Before you publish the crate, please ensure docs.rs will activate the <code>docsrs</code> attribute.
Feel free to go back to the chapter about the <a href="tutorial/high_level_rust_api.html#the-cargotoml-file">Cargo.toml file of the safe wrapper</a> to read more about it.
If you skip this step, your crate and all crates depending on it will not have documentation available on docs.rs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>GIR uses two configurations files, one for generating the FFI part of the bindings and the other file for the Rust API.
The configuration files must be named <code>Gir.toml</code></p>
<ul>
<li>
<p>The FFI configuration allows things such as ignoring objects, overriding the minimum required version for a specific type or renaming the generated crate name.</p>
</li>
<li>
<p>The Rust API configuration is a bit more complex as it allows configuring Objects, Enums, Bitfields, Functions, Properties, Signals and a few other things.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi-options"><a class="header" href="#ffi-options">FFI Options</a></h1>
<p>In FFI (<code>-m sys</code>) mode, <code>gir</code> generates as much as it can.
So in this mode, the TOML file is mostly used to ignore some objects.
To do so, you need to add its fullname to an <code>ignore</code> array.
Example:</p>
<pre><code class="language-toml">ignore = ["Gtk.Widget", "Gtk.Window"]
</code></pre>
<p>And that's all.
Neither <code>GtkWidget</code> nor <code>GtkWindow</code> (alongside with their functions) will be generated.</p>
<p>You also need to add any needed external libraries in the "external_libraries" parameter.
Example:</p>
<pre><code class="language-toml">[options]
external_libraries = [
   "GLib",
   "GObject",
]
</code></pre>
<p>You can specify a few other options:</p>
<pre><code class="language-toml">[options]
girs_directories = ["../gir-files"]
library = "GtkSource"
version = "3.0"
min_cfg_version = "3.0"
target_path = "."
# Path where lib.rs generated (defaults to &lt;target_path&gt;/src)
# auto_path = "src"
work_mode = "sys"
# If true then build.rs will be split into 2 parts:
# always generated build_version.rs,
# and build.rs that generated only if not exists.
# Defaults to false
split_build_rs = false
# Adds extra versions to features
extra_versions = [
   "3.15",
   "3.17",
]
# Change library version for version
[[lib_version_overrides]]
version = "3.16"
lib_version = "3.16.1"
# Add extra dependencies to feature
[[feature_dependencies]]
version = "3.16"
dependencies = [
  "glib-sys/v3_16"
]
</code></pre>
<p>Also, you can add rust cfg conditions on objects, functions and constants, for example, when flagging for conditional compilation:</p>
<pre><code class="language-toml">[[object]]
name = "GstGL.GLDisplayEGL"
status = "generate"
cfg_condition = "feature = \"egl\""
    [[object.function]]
    pattern = ".*"
    cfg_condition = "feature = \"egl\""
</code></pre>
<h2 id="generation-in-ffi-mode"><a class="header" href="#generation-in-ffi-mode">Generation in FFI mode</a></h2>
<p>When you're ready, let's generate the FFI part.
In the command we'll execute, <code>../gir-files</code> is where the directory with your <code>.gir</code> files is.
(But again, you can just clone the <a href="https://github.com/gtk-rs/gir-files">gir-files repository</a> and add your file(s) in it).
Then let's run the command:</p>
<pre><code class="language-sh">cargo run --release -- -c YourSysGirFile.toml -d ../gir-files -m sys -o the-output-directory-sys
</code></pre>
<p>The generated files will be placed in <code>the-output-directory-sys</code>.
Just take care about the dependencies and the crate's name generated in the <code>Cargo.toml</code> file (update them if they don't work as expected).</p>
<p>You now have the sys part of your binding!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-options"><a class="header" href="#api-options">API Options</a></h1>
<p>This mode requires you to write another TOML file.
<a href="https://github.com/gtk-rs/gtk/blob/main/Gir.toml">gtk/Gir.toml</a> is a good example.</p>
<pre><code class="language-toml">[options]
girs_directories = ["gir-files"]
library = "Gtk"
version = "3.0"
min_cfg_version = "3.4"
target_path = "."
# Path where objects generated (defaults to &lt;target_path&gt;/src/auto)
# auto_path = "src/auto"
work_mode = "normal"
# Whether the library uses https://gitlab.gnome.org/GNOME/gi-docgen for its documentation
use_gi_docgen = false
generate_safety_asserts = true
deprecate_by_min_version = true
# With this option enabled, versions for gir and gir-files saved only to one file to minimize noise,
# can also take path to the directory for saving "versions.txt" or filename with extension.
# Relative to target_path
single_version_file = true
# Trust the nullability information about return values. If this is disabled
# then any pointer return type is assumed to be nullable unless there is an
# explicit override for it.
# This has to be used carefully as many libraries are missing nullable
# annotations for return values, which then will cause a panic once an
# unexpected NULL is returned.
trust_return_value_nullability = false
# Disable running `cargo fmt` on generated files
# (defaults to false)
disable_format = true
# Always generate a Builder if possible. This is mostly a convenient setter as most of the
# time you might want the Builder to be generated. Ignoring none-desired ones can still be done with per object `generate_builder` configuration.
# (defaults to false)
generate_builder = true
</code></pre>
<p>This mode generates only the specified objects.
You can either add the object's fullname to the <code>generate</code> array or add it to the <code>manual</code> array (but in this case, it won't be generated, just used in other functions/methods instead of generating an "ignored" argument).
Example:</p>
<pre><code class="language-toml">generate = ["Gtk.Widget", "Gtk.Window"]
manual = ["Gtk.Button"]
</code></pre>
<p>So in here, both <code>GtkWidget</code> and <code>GtkWindow</code> will be fully generated and functions/methods using <code>GtkButton</code> will be uncommented.
To generate code for all global functions, add <code>Gtk.*</code> to the <code>generate</code> array.</p>
<p>To also generate a <code>Builder</code> struct for a widget, it needs to be set with the <code>generate_builder</code> flag in object configuration:</p>
<pre><code class="language-toml">[[object]]
name = "Gtk.TreeView"
status = "generate"
generate_builder = true
</code></pre>
<blockquote>
<p>If the object doesn't already have a <code>Default</code> implementation through a constructor method without arguments, generating a <code>Builder</code> struct will add a <code>Default</code> implementation for the object.</p>
</blockquote>
<p>If you want to remove warning messages about the not bound <code>Builders</code> during the generation you don't want to be generated, you can ignore them with the <code>generate_builder</code> flag in object configuration:</p>
<pre><code class="language-toml">[[object]]
name = "Gtk.TreeView"
status = "generate"
generate_builder = false
</code></pre>
<p>If there is some work which has to be done post-construction before the builder's
<code>build</code> method returns, you can set the <code>builder_postprocess</code> value in the object configuration:</p>
<pre><code class="language-toml">[[object]]
name = "Gtk.Application"
status = "generate"
generate_builder = true
builder_postprocess = "Application::register_startup_hook(&amp;ret);"
</code></pre>
<p>For the duration of the code in <code>builder_postprocess</code> the binding <code>ret</code> will be the
value to be returned from the <code>build</code> method.</p>
<p>Sometimes Gir understands the object definition incorrectly or the <code>.gir</code> file contains an incomplete or wrong definition, to fix it, you can use the full object configuration:</p>
<pre><code class="language-toml">[[object]]
# object's fullname
name = "Gtk.SomeClass"
# can be also "manual" and "ignore" but it's simpler to just put the object in the same array
status = "generate"
# replace the parameter name for the child in child properties (instead "child")
child_name = "item"
# mark object as final type, i.e. one without any further subclasses. this
# will not generate trait SomeClassExt for this object, but implement all
# functions in impl SomeClass
final_type = true
# mark the object as a fundamental type in case the GIR file lacks the annotation
# note that fundamental types don't make use of IsA/Cast traits and you should
# implement something similar manually
# gir is only capable for generating the type definitions along with their functions
fundamental_type = false
# mark the enum as exhaustive. This must only be done if it is impossible for
# the C library to add new variants to the enum at a later time but allows
# for more optimal code to be generated.
exhaustive = false
# allow rename result file
module_name = "soome_class"
# override starting version
version = "3.12"
# prefixed object in mod.rs with #[cfg(mycond)]
cfg_condition = "mycond"
# if you want to generate builder with name SomeClassBuilder
generate_builder = true
# trust return value nullability annotations for this specific type.
# See above for details and use with care
trust_return_value_nullability = false
# Tweak the visibility of the type
visibility = "pub" # or 'crate' / 'private' / 'super'
# The default value to used for the `Default` implementation. It only
# works for flags and enums. You have to pass the "GIR" member name.
default_value = "fill"
# Change the name of the generated trait to e.g avoid naming conflicts
trait_name = "TraitnameExt" 
# In case you don't want to generate the documentation for this type.
generate_doc = false
    # define overrides for function
    [[object.function]]
    # filter functions from object
    name = "set_website_label"
    # alternative way to apply override for many functions. Will be used with '^' and '$' on both sides
    # can be used instead of `name` almost anywhere
    # pattern = "[gs]et_value"
    # don't generate function
    ignore = true
    # override starting version
    version = "3.12"
    # prefixed function with #[cfg(mycond)]
    cfg_condition = "mycond"
    # prefixed function with #[doc(hidden)]
    doc_hidden = true
    # define a list of function parameters to be ignored when the documentation is generated
    doc_ignore_parameters = ["some_user_data_param"]
    # disable length_of autodetection
    disable_length_detect = true
    # write function docs to trait other than default "xxxExt",
    # also works in [object.signal] and [object.property]
    doc_trait_name = "SocketListenerExtManual"
    # disable generation of future for async function
    no_future = true
    # to rename the generated function
    rename = "something_else"
    # to override the default safety assertions: "none", "skip",
    # "not-initialized", "in-main-thread"
    assertion = "in-main-thread"
    # Tweak the visibility of the function
    visibility = "pub" # or 'crate' / 'private' / 'super'
    # In case you don't want to generate the documentation for this method.
    generate_doc = false
        # override for parameter
        [[object.function.parameter]]
        # filter by name
        name = "website_label"
        # allow to remove/add Option&lt;&gt;
        nullable = true
        # Take the parameter by value instead of by ref
        move = true
        # allow to make parameter immutable
        const = true
        # parameter is calculated as length of string or array and removed from function declaration
        # (for length of return value use "return")
        length_of = "str"
        # change string type. Variants: "utf8", "filename", "os_string"
        string_type = "os_string"
        # make function unsafe to call (emits `fn unsafe`)
        unsafe = true

        # override for return value
        [object.function.return]
        # allow to remove/add Option&lt;&gt; to return value
        nullable = true
        # convert bool return types to Result&lt;(), glib::BoolError&gt; with
        # the given error message on failure
        bool_return_is_error = "Function failed doing what it is supposed to do"
        # convert Option return types to Result&lt;T, glib::BoolError&gt; with
        # the given error message on failure
        nullable_return_is_error = "Function failed doing what it is supposed to do"
        # always include the return value of throwing functions in the returned Result&lt;...&gt;,
        # without this option bool and guint return values are assumed to indicate success or error,
        # and are not included in the returned Result&lt;...&gt;
        use_return_for_result = true
        # change string type. Variants: "utf8", "filename", "os_string"
        string_type = "os_string"
        # overwrite type
        type = "Gtk.Widget"

            # Override callback's parameter
            [[object.function.parameter.callback_parameter]]
            name = "name_of_the_callback_parameter"
            nullable = true
    # virtual methods support the same configuration for parameters and return types as functions
    # note that they are not used for code generation yet.
    [[object.virtual_method]]
    # filter virtual method from object
    name = "set_website_label"
    # alternative way to apply override for many functions. Will be used with '^' and '$' on both sides
    # can be used instead of `name` almost anywhere
    # pattern = "[gs]et_value"
    # don't generate function
    ignore = true
    # override starting version
    version = "3.12"
    # prefixed function with #[cfg(mycond)]
    cfg_condition = "mycond"
    # prefixed function with #[doc(hidden)]
    doc_hidden = true
    # define a list of function parameters to be ignored when the documentation is generated
    doc_ignore_parameters = ["some_user_data_param"]
    # write function docs to trait other than default "xxxExt",
    # also works in [object.signal] and [object.property]
    doc_trait_name = "SocketListenerExtManual"
    # to rename the generated function
    rename = "something_else"
    # In case you don't want to generate the documentation for this method.
    generate_doc = false
    [[object.signal]]
    name = "activate-link"
    # replace trampoline bool return type with `Inhibit`
    inhibit = true
    ignore = true
    version = "3.10"
    doc_hidden = true
    # In case you don't want to generate the documentation for this signal.
    generate_doc = false
        [[object.signal.parameter]]
        name = "path_string"
        # allow to use different names in closure
        new_name = "path"
        # can be also "borrow" and "none": Add some transformation between ffi trampoline parameters and rust closure
        transformation = "treepath"
        nullable = true
        [object.signal.return]
        nullable = true
    # override for properties
    [[object.property]]
    name = "baseline-position"
    version = "3.10"
    ignore = true
    # In case you don't want to generate the documentation for this property.
    generate_doc = false
    [[object.property]]
    name = "events"
    # generate only `connect_property_events_notify`, without `get_property_events` and `set_property_events`
    # supported values: "get", "set", "notify"
    generate = ["notify"]
</code></pre>
<p>Since there are no child properties in <code>.gir</code> files, it needs to be added for classes manually:</p>
<pre><code class="language-toml">[[object]]
name = "Gtk.SomeClassWithChildProperties"
status = "generate"
# replace parameter name for child in child properties (instead of "child")
child_name = "item"
# define concrete child type (instead of "Widget")
child_type = "Gtk.MenuItem"
    [[object.child_prop]]
    name = "position"
    type = "gint"
    doc_hidden = true
</code></pre>
<p>For enumerations and bitflags, you can configure the members and mark the type
as <code>#[must_use]</code>:</p>
<pre><code class="language-toml">[[object]]
name = "Gdk.EventType"
status = "generate"
# generates #[must_use] attribute for the type
must_use = true
# override starting version
version = "3.12"
    [[object.member]]
    name = "2button_press"
    # allows to skip elements with bad names, other members with same value used instead
    ignore = true
    # Allow to add a cfg condition
    cfg_condition = "target_os = \"linux\""
    # In case you don't want to generate the documentation for this member.
    generate_doc = false
    [[object.member]]
    name = "touchpad_pinch"
    # define starting version when member added
    version = "3.18"
</code></pre>
<p>For enumerations and bitflags, you can also configure additional <code>#[derive()]</code>
clauses optionally conditioned to a <code>cfg</code>.</p>
<pre><code class="language-toml">[[object]]
name = "Gst.Format"
status = "generate"
    [[object.derive]]
    name = "Serialize, Deserialize"
    cfg_condition = "feature = \"serde\""
</code></pre>
<p>For global functions, the members can be configured by configuring the <code>Gtk.*</code> object:</p>
<pre><code class="language-toml">[[object]]
name = "Gtk.*"
status = "generate"
    [[object.function]]
    name = "stock_list_ids"
    # allows to ignore global functions
    ignore = true
    # allows to define if the function was moved to a trait 
    doc_trait_name = "StockExt"
    # allows to define if the function was moved to a struct
    doc_struct_name = "Stock"
    # In case you don't want to generate the documentation for this function.
    generate_doc = false
</code></pre>
<p>Which will prevent gir from generating <code>stock_list_ids</code>.
If you want to specify
that a function will be manually implemented, you can use:</p>
<pre><code class="language-toml">[[object]]
name = "Gtk.Entry"
status = "generate"
    [[object.function]]
    name = "get_invisible_char"
    manual = true
</code></pre>
<p>This will prevent gir from generating <code>get_invisible_char</code> and it won't generate
<code>get_property_invisible_char</code> which would have been generated if we had used
"ignore = true".</p>
<p>Note that you must not place <code>Gtk.*</code> into the <code>generate</code> array and
additionally configure its members.</p>
<p>You can control the generation of constants in a similar fashion:</p>
<pre><code class="language-toml">[[object]]
name = "Gtk.*"
status = "generate"
    [[object.constant]]
    pattern = "*"
    # No constants will be generated
    ignore = true
    # In case you don't want to generate the documentation for this constant.
    generate_doc = false
</code></pre>
<p>Constants also support <code>version</code> and <code>cfg_condition</code> fields.</p>
<p>In various cases, GObjects or boxed types can be used from multiple threads
and have certain concurrency guarantees.
This can be configured with the
<code>concurrency</code> setting at the top-level options or per object.
It will
automatically implement the <code>Send</code> and <code>Sync</code> traits for the resulting object
and set appropriate trait bounds for signal callbacks.
The default is <code>none</code>,
and apart from that <code>send</code> and <code>send+sync</code> are supported.</p>
<pre><code class="language-toml">[[object]]
# object's fullname
name = "Gtk.SomeClass"
# can be also "manual" and "ignore" but it's simpler to just put the object in the same array
status = "generate"
# concurrency of the object, default is set in the top-level options or
# otherwise "none". Valid values are "none", "send" and "send+sync"
concurrency = "send+sync"
</code></pre>
<p>Note that <code>send</code> is only valid for types that are either not reference counted
(i.e. <code>clone()</code> copies the object) or that are read-only (i.e. no API for
mutating the object exists).
<code>send+sync</code> is valid if the type can be sent to
different threads and all API allows simultaneous calls from different threads
due to internal locking via e.g. a mutex.</p>
<pre><code class="language-toml">[[object]]
name = "Gtk.Something"
status = "manual"
# Can also be "ref-mut", "ref-immut"
ref_mode = "ref"
</code></pre>
<p>When manually generating bindings, it can happen that the reference mode
detected by GIR is different than what was implemented and conversion to the C
types are wrong in autogenerated functions that have such objects as argument.
This can be overridden with the <code>ref_mode</code> configuration.</p>
<p>Getters are automatically renamed to comply with Rust codying style guidelines.
However, this can cause name clashes with existing functions.
If you want to
bypass the automatic renaming mechanism, use <code>bypass_auto_rename = true</code>:</p>
<pre><code class="language-toml">[[object]]
name = "Gtk.TextBuffer"
[...]
    [[object.function]]
    name = "get_insert"
    # Avoid clash with the `insert` operation.
    bypass_auto_rename = true
</code></pre>
<p>Some constructors are not annotated as <code>constructor</code> in the <code>gir</code> files.
In
order for the naming convention to be applied, you can force a function to be
considered as a constructor:</p>
<pre><code class="language-toml">[[object.function]]
name = "new_for_path"
# Not annotated as constructor in Gir =&gt; force it to apply naming convention
constructor = true
</code></pre>
<h2 id="conversion_type-option"><a class="header" href="#conversion_type-option">conversion_type "Option"</a></h2>
<p>The <code>conversion_type</code> variant <code>Option</code> is available for types <code>T</code> implementing
<code>glib::TryFromGlib&lt;Error=GlibNoneError&gt;</code>.
As a reminder, this allows
implementing <code>FromGlib</code> for <code>Option&lt;T&gt;</code> and usually goes alongside with <code>ToGlib</code>
for both <code>T</code> and <code>Option&lt;T&gt;</code>.
In this case, <code>Option&lt;T&gt;</code> will be used for return
values (including ffi output arguments).
For in-arguments, except if the
parameter is declared <code>mandatory</code>, <code>impl Into&lt;Option&lt;T&gt;&gt;</code> so that either an
<code>Option&lt;T&gt;</code> or <code>T</code> can be used.</p>
<p>Ex. from <code>gstreamer-rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[[object]]
name = "Gst.ClockTime"
status = "manual"
conversion_type = "Option"
<span class="boring">}</span></code></pre></pre>
<p>The type <code>ClockTime</code> implements <code>glib::TryFromGlib&lt;Error=GlibNoneError&gt;</code> (and
<code>OptionToGlib</code>), which means that its Rust representation can take advantage of
<code>Option&lt;ClockTime&gt;</code>.</p>
<p>Additionally, the user can instruct <code>gir</code> to <code>expect</code> <code>Some</code> or <code>Ok</code> results for
specific arguments or return values.
E.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[[object]]
name = "Gst.Clock"
status = "generate"
manual_traits = ["ClockExtManual"]
    [[object.function]]
    name = "get_calibration"
        [[object.function.parameter]]
        name = "internal"
        mandatory = true
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the user instructs gir to consider the <code>internal</code> argument (which also happens to be an out argument) with type gir <code>Gst.ClockTime</code> can be represented as a <code>ClockTime</code> without the <code>Option</code>.
This argument is actually part of a set of output arguments.
With the above gir declaration, the generated signature is the following (the implementation takes care of <code>expect</code>ing the value to be defined):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn get_calibration(
        &amp;self,
    ) -&gt; (
        ClockTime,
        Option&lt;ClockTime&gt;,
        Option&lt;ClockTime&gt;,
        Option&lt;ClockTime&gt;,
    );
<span class="boring">}</span></code></pre></pre>
<p>For a return value, the mandatory declaration reads:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    [[object.function]]
    name = "util_get_timestamp"
    /.../
        [object.function.return]
<span class="boring">        always returns a value
</span>        mandatory = true
<span class="boring">}</span></code></pre></pre>
<h2 id="conversion_type-result"><a class="header" href="#conversion_type-result">conversion_type "Result"</a></h2>
<p>The <code>conversion_type</code> variant <code>Result</code> is available for types <code>T</code> implementing
<code>glib::TryFromGlib&lt;Error=Err&gt;</code> where <code>Err</code> is neither <code>GlibNoneError</code> nor
<code>GlibNoneOrInvalidError</code>.
In this case, <code>Result&lt;T, ErrorType&gt;</code> will be used for
return values (including <code>ffi</code> output arguments) and the type itself in argument
position.</p>
<p>In <code>gstreamer-rs</code>, the C type <code>GstStateChangeReturn</code> can represent both a
successful or an error return value.
In Rust, the <code>Result</code> <code>enum</code> is the idiomatic way of returning an error.
In <code>gstreamer-rs</code>, bindings to functions
returning <code>GstStateChangeReturn</code> had to be manually implemented so as to return <code>Result&lt;StateChangeSuccess, StateChangeError&gt;</code>.
Note that in this case, the type implementing <code>TryFromGlib</code> is <code>StateChangeSuccess</code> and not
<code>GstStateChangeReturn</code>.
These functions can be auto-generated using:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[[object]]
name = "Gst.StateChangeReturn"
status = "generate"
must_use = true
    [object.conversion_type]
    variant = "Result"
    ok_type = "gst::StateChangeSuccess"
    err_type = "gst::StateChangeError"
<span class="boring">}</span></code></pre></pre>
<h2 id="boxed-types-vs-boxedinline-types"><a class="header" href="#boxed-types-vs-boxedinline-types">Boxed types vs. BoxedInline types</a></h2>
<p>For boxed types / records, gir auto-detects <code>copy</code>/<code>free</code> or <code>ref</code>/<code>unref</code>
function pairs for memory management on records.
It falls back to generic <code>g_boxed_copy</code>/<code>g_boxed_free</code> if these are not found, based on an existing implementation of <code>get_type</code>.
Otherwise no record implementation can be generated.</p>
<p>This works for the majority of boxed types, which are literally boxed: their
memory is always allocated on the heap and memory management is left to the C library.
Some boxed types, however, are special and in C code they are usually allocated on the stack or inline inside another struct.
As such, their struct definition is public and part of the API/ABI.
Usually these types are relatively small and allocated regularly, which would make heap allocations costly.</p>
<p>These special boxed types are usually allocated by the caller of the C
functions, and the functions are then only filling in the memory and taking
values of this type as <code>(out caller-allocates)</code> parameters.</p>
<p>In most other bindings, heap allocations are used for these boxed types too
but in Rust we can do better and actually allocate them on the stack or inline
inside another struct.</p>
<p>Gir calls these special boxed types "boxed inline".</p>
<pre><code class="language-toml">[[object]]
name = "GLib.TreeIter"
status = "generate"
boxed_inline = true
</code></pre>
<p>For inline-allocated boxed types it is possible to provide Rust expressions in
the configuration for initializing newly allocated memory for them, to copy
from one value into another one, and to free any resources that might be
stored in values of that boxed types.</p>
<p>By default the memory is zero-initialized and copying is done via
<code>std::ptr::copy()</code>.
If the boxed type contains memory that needs to be freed
then these functions must be provided.</p>
<p>The following configuration is equivalent with the one above.</p>
<pre><code class="language-toml">[[object]]
name = "GLib.TreeIter"
status = "generate"
boxed_inline = true
init_function_expression = "|_ptr| ()"
copy_into_function_expression = "|dest, src| { std::ptr::copy_nonoverlapping(src, dest, 1); }"
clear_function_expression = "|_ptr| ()"
</code></pre>
<h2 id="generation-in-api-mode"><a class="header" href="#generation-in-api-mode">Generation in API mode</a></h2>
<p>To generate the Rust-user API level, The command is very similar to the previous one.
It's better to not put this output in the same directory as where the FFI files are.
Just run:</p>
<pre><code class="language-sh">cargo run --release -- -c YourGirFile.toml -d ../gir-files -o the-output-directory
</code></pre>
<p>Now it should be done.
Just go to the output directory (so <code>the-output-directory/auto</code> in our case) and try to build using <code>cargo build</code>.
Don't forget to update your dependencies in both projects: nothing much to do in the FFI/sys one but the Rust-user API level will need to have a dependency over the FFI/sys one.</p>
<p>Now, at your crate entry point (generally <code>lib.rs</code>), add the following to include all generated files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use auto::*;
<span class="boring">}</span></code></pre></pre>
<h2 id="add-manual-bindings-alongside-generated-code"><a class="header" href="#add-manual-bindings-alongside-generated-code">Add manual bindings alongside generated code</a></h2>
<p>Unfortunately, <code>gir</code> isn't perfect (yet) and will certainly not be able to generate all the code on its own.
So here's what a <code>gir</code> generated folder looks like:</p>
<pre><code class="language-text">- your_folder
|
|- Cargo.toml
|- src
 |
 |- lib.rs
 |- auto
  |
  |- (all files generated by gir)
</code></pre>
<p>You can add your manual bindings directly inside the <code>src</code> folder (at the same level as <code>lib.rs</code>).
Then don't forget to reexport them.
Let's say you added a <code>Color</code> type in a <code>color.rs</code> file.
You need to add in <code>lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We make the type public for the API users.
pub use color::Color;

mod color;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate-name-overrides"><a class="header" href="#crate-name-overrides">Crate name overrides</a></h1>
<p><code>gir</code> uses simple rule to convert a namespace to a crate name and it sometimes goes wrong.
For example, "WebKit2WebExtension" namespace will be converted to "web_kit2_web_extension", which looks bad.</p>
<p>To fix it, the <code>crate_name_overrides</code> option can be used.</p>
<p>It also replaces FFI crates' name.</p>
<pre><code class="language-toml">[crate_name_overrides]
"web_kit2_web_extension" = "webkit2_webextension"
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
