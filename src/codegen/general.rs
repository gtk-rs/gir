use std::fmt::Display;
use std::io::{Result, Write};

use analysis;
use analysis::general::StatusedTypeId;
use analysis::imports::Imports;
use analysis::namespaces;
use config::Config;
use config::derives::Derive;
use env::Env;
use gir_version::VERSION;
use version::Version;
use writer::primitives::tabs;

pub fn start_comments(w: &mut Write, conf: &Config) -> Result<()> {
    if conf.single_version_file.is_some() {
        return start_comments_no_version(w);
    }
    writeln!(
        w,
        "// This file was generated by gir (https://github.com/gtk-rs/gir @ {})
// from gir-files (https://github.com/gtk-rs/gir-files @ {})
// DO NOT EDIT",
        VERSION, conf.girs_version
    )
}

pub fn start_comments_no_version(w: &mut Write) -> Result<()> {
    writeln!(
        w,
        "// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT"
    )
}

pub fn single_version_file(w: &mut Write, conf: &Config) -> Result<()> {
    writeln!(
        w,
        "Generated by gir (https://github.com/gtk-rs/gir @ {})
from gir-files (https://github.com/gtk-rs/gir-files @ {})",
        VERSION, conf.girs_version
    )
}

pub fn uses(w: &mut Write, env: &Env, imports: &Imports) -> Result<()> {
    writeln!(w)?;
    for (name, &(ref version, ref constraints)) in imports.iter() {
        if constraints.len() == 1 {
            writeln!(w, "#[cfg(feature = \"{}\")]", constraints[0])?;
        } else if !constraints.is_empty() {
            writeln!(w, "#[cfg(any({}))]", constraints.iter().map(|c| format!("feature = \"{}\"", c)).collect::<Vec<_>>().join(", "))?;
        }

        version_condition(w, env, *version, false, 0)?;
        let mut default_use = true;
        if env.namespaces.is_glib_crate {
            if name == "glib_ffi" {
                writeln!(w, "use ffi as {};", name)?;
                default_use = false;
            } else if env.namespaces.glib_ns_id != namespaces::MAIN && name == "ffi" {
                writeln!(w, "use gobject_ffi as {};", name)?;
                default_use = false;
            }
        }
        if default_use {
            writeln!(w, "use {};", name)?;
        }
    }

    Ok(())
}

pub fn define_object_type(
    w: &mut Write,
    env: &Env,
    type_name: &str,
    glib_name: &str,
    glib_class_name: &Option<&str>,
    rust_class_name: &Option<&str>,
    glib_func_name: &str,
    parents: &[StatusedTypeId],
) -> Result<()> {
    let mut external_parents = false;
    let parents: Vec<String> = parents
        .iter()
        .filter(|p| !p.status.ignored())
        .map(|p| if p.type_id.ns_id == namespaces::MAIN {
            p.name.clone()
        } else {
            external_parents = true;
            format!(
                "{krate}::{name} => {krate}_ffi::{ffi_name}",
                krate = env.namespaces[p.type_id.ns_id].crate_name,
                name = p.name,
                ffi_name = env.library.type_(p.type_id).get_glib_name().unwrap()
            )
        })
        .collect();

    let (separator, class_name) = {
        if let Some(s) = *glib_class_name {
            (", ".to_string(), format!("ffi::{}", s))
        } else {
            ("".to_string(), "".to_string())
        }
    };

    let rust_class_name = match rust_class_name {
        None => String::new(),
        Some(ref rust_class_name) => format!(", {}", rust_class_name),
    };

    writeln!(w)?;
    writeln!(w, "glib_wrapper! {{")?;
    if parents.is_empty() {
        writeln!(
            w,
            "\tpub struct {}(Object<ffi::{}{}{}{}>);",
            type_name,
            glib_name,
            separator,
            class_name,
            rust_class_name
        )?;
    } else if external_parents {
        writeln!(
            w,
            "\tpub struct {}(Object<ffi::{}{}{}{}>): [",
            type_name,
            glib_name,
            separator,
            class_name,
            rust_class_name
        )?;
        for parent in parents {
            writeln!(w, "\t\t{},", parent)?;
        }
        writeln!(w, "\t];")?;
    } else {
        writeln!(
            w,
            "\tpub struct {}(Object<ffi::{}{}{}{}>): {};",
            type_name,
            glib_name,
            separator,
            class_name,
            rust_class_name,
            parents.join(", ")
        )?;
    }
    writeln!(w)?;
    writeln!(w, "\tmatch fn {{")?;
    writeln!(w, "\t\tget_type => || ffi::{}(),", glib_func_name)?;
    writeln!(w, "\t}}")?;
    writeln!(w, "}}")?;

    Ok(())
}

pub fn define_boxed_type(
    w: &mut Write,
    type_name: &str,
    glib_name: &str,
    copy_fn: &str,
    free_fn: &str,
    get_type_fn: &Option<String>,
    derive: &[Derive],
) -> Result<()> {
    writeln!(w)?;
    writeln!(w, "glib_wrapper! {{")?;

    derives(w, derive, 1)?;
    writeln!(
        w,
        "\tpub struct {}(Boxed<ffi::{}>);",
        type_name,
        glib_name
    )?;
    writeln!(w)?;
    writeln!(w, "\tmatch fn {{")?;
    writeln!(
        w,
        "\t\tcopy => |ptr| ffi::{}(mut_override(ptr)),",
        copy_fn
    )?;
    writeln!(w, "\t\tfree => |ptr| ffi::{}(ptr),", free_fn)?;
    if let Some(ref get_type_fn) = *get_type_fn {
        writeln!(w, "\t\tget_type => || ffi::{}(),", get_type_fn)?;
    }
    writeln!(w, "\t}}")?;
    writeln!(w, "}}")?;

    Ok(())
}

pub fn define_auto_boxed_type(
    w: &mut Write,
    type_name: &str,
    glib_name: &str,
    get_type_fn: &str,
    derive: &[Derive],
) -> Result<()> {
    writeln!(w)?;
    writeln!(w, "glib_wrapper! {{")?;
    derives(w, derive, 1)?;
    writeln!(
        w,
        "\tpub struct {}(Boxed<ffi::{}>);",
        type_name,
        glib_name
    )?;
    writeln!(w)?;
    writeln!(w, "\tmatch fn {{")?;
    writeln!(
        w,
        "\t\tcopy => |ptr| gobject_ffi::g_boxed_copy(ffi::{}(), ptr as *mut _) as *mut ffi::{},",
        get_type_fn, glib_name
    )?;
    writeln!(
        w,
        "\t\tfree => |ptr| gobject_ffi::g_boxed_free(ffi::{}(), ptr as *mut _),",
        get_type_fn
    )?;
    writeln!(w, "\t\tget_type => || ffi::{}(),", get_type_fn)?;
    writeln!(w, "\t}}")?;
    writeln!(w, "}}")?;

    Ok(())
}

pub fn define_shared_type(
    w: &mut Write,
    type_name: &str,
    glib_name: &str,
    ref_fn: &str,
    unref_fn: &str,
    get_type_fn: &Option<String>,
    derive: &[Derive],
) -> Result<()> {
    writeln!(w)?;
    writeln!(w, "glib_wrapper! {{")?;
    derives(w, derive, 1)?;
    writeln!(
        w,
        "\tpub struct {}(Shared<ffi::{}>);",
        type_name,
        glib_name
    )?;
    writeln!(w)?;
    writeln!(w, "\tmatch fn {{")?;
    writeln!(w, "\t\tref => |ptr| ffi::{}(ptr),", ref_fn)?;
    writeln!(w, "\t\tunref => |ptr| ffi::{}(ptr),", unref_fn)?;
    if let Some(ref get_type_fn) = *get_type_fn {
        writeln!(w, "\t\tget_type => || ffi::{}(),", get_type_fn)?;
    }
    writeln!(w, "\t}}")?;
    writeln!(w, "}}")?;

    Ok(())
}

pub fn cfg_deprecated(
    w: &mut Write,
    env: &Env,
    deprecated: Option<Version>,
    commented: bool,
    indent: usize,
) -> Result<()> {
    if let Some(s) = cfg_deprecated_string(deprecated, env, commented, indent) {
        writeln!(w, "{}", s)?;
    }
    Ok(())
}

pub fn cfg_deprecated_string(
    deprecated: Option<Version>,
    env: &Env,
    commented: bool,
    indent: usize,
) -> Option<String> {
    let comment = if commented { "//" } else { "" };
    if env.is_too_low_version(deprecated) {
        Some(format!("{}{}#[deprecated]", tabs(indent), comment))
    } else if let Some(v) = deprecated {
        Some(format!(
            "{}{}#[cfg_attr({}, deprecated)]",
            tabs(indent),
            comment,
            v.to_cfg()
        ))
    } else {
        None
    }
}

pub fn version_condition(
    w: &mut Write,
    env: &Env,
    version: Option<Version>,
    commented: bool,
    indent: usize,
) -> Result<()> {
    if let Some(s) = version_condition_string(env, version, commented, indent) {
        writeln!(w, "{}", s)?;
    }
    Ok(())
}

pub fn version_condition_string(
    env: &Env,
    version: Option<Version>,
    commented: bool,
    indent: usize,
) -> Option<String> {
    match version {
        Some(v) if v > env.config.min_cfg_version => {
            let comment = if commented { "//" } else { "" };
            Some(format!(
                "{}{}#[cfg(any({}, feature = \"dox\"))]",
                tabs(indent),
                comment,
                v.to_cfg()
            ))
        }
        _ => None,
    }
}

pub fn not_version_condition(
    w: &mut Write,
    version: Option<Version>,
    commented: bool,
    indent: usize,
) -> Result<()> {
    if let Some(v) = version {
        let comment = if commented { "//" } else { "" };
        let s = format!(
            "{}{}#[cfg(any(not({}), feature = \"dox\"))]",
            tabs(indent),
            comment,
            v.to_cfg()
        );
        writeln!(w, "{}", s)?;
    }
    Ok(())
}

pub fn cfg_condition(
    w: &mut Write,
    cfg_condition: &Option<String>,
    commented: bool,
    indent: usize,
) -> Result<()> {
    let s = cfg_condition_string(cfg_condition, commented, indent);
    if let Some(s) = s {
        writeln!(w, "{}", s)?;
    }
    Ok(())
}

pub fn cfg_condition_string(
    cfg_condition: &Option<String>,
    commented: bool,
    indent: usize,
) -> Option<String> {
    match cfg_condition.as_ref() {
        Some(v) => {
            let comment = if commented { "//" } else { "" };
            Some(format!(
                "{}{}#[cfg(any({}, feature = \"dox\"))]",
                tabs(indent),
                comment,
                v
            ))
        }
        None => None,
    }
}

pub fn derives(
    w: &mut Write,
    derives: &[Derive],
    indent: usize,
) -> Result<()> {
    for derive in derives {
        let s = match &derive.cfg_condition {
            Some(condition) => format!(
                "#[cfg_attr({}, derive({}))]",
                condition,
                derive.names.join(", ")
            ),
            None => format!("#[derive({})]", derive.names.join(", ")),
        };
        writeln!(w, "{}{}", tabs(indent), s)?;
    }
    Ok(())
}

pub fn doc_hidden(
    w: &mut Write,
    doc_hidden: bool,
    comment_prefix: &str,
    indent: usize,
) -> Result<()> {
    if doc_hidden {
        writeln!(w, "{}{}#[doc(hidden)]", tabs(indent), comment_prefix)
    } else {
        Ok(())
    }
}

pub fn write_vec<T: Display>(w: &mut Write, v: &[T]) -> Result<()> {
    for s in v {
        writeln!(w, "{}", s)?;
    }
    Ok(())
}

pub fn declare_default_from_new(
    w: &mut Write,
    env: &Env,
    name: &str,
    functions: &[analysis::functions::Info],
) -> Result<()> {
    if let Some(func) = functions.iter().find(|f| {
        !f.visibility.hidden() && f.name == "new" && f.parameters.rust_parameters.is_empty()
    }) {
        writeln!(w)?;
        cfg_deprecated(w, env, func.deprecated_version, false, 0)?;
        version_condition(w, env, func.version, false, 0)?;
        writeln!(w, "impl Default for {} {{", name)?;
        writeln!(w, "    fn default() -> Self {{")?;
        writeln!(w, "        Self::new()")?;
        writeln!(w, "    }}")?;
        writeln!(w, "}}")?;
    }

    Ok(())
}

/// Escapes string in format suitable for placing inside double quotes.
pub fn escape_string(s: &str) -> String {
    let mut es = String::with_capacity(s.len() * 2);
    let _ = s.chars()
        .map(|c| match c {
            '\"' | '\\' => {
                es.push('\\');
                es.push(c)
            }
            _ => es.push(c),
        })
        .count();
    es
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_escape_string() {
        assert_eq!(escape_string(""),
                   "");
        assert_eq!(escape_string("no escaping here"),
                   "no escaping here");
        assert_eq!(escape_string(r#"'"\"#),
                   r#"'\"\\"#);
    }
}
